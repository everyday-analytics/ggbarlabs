---
output: 
  github_document:
    toc: TRUE
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "50%"
)
```


```{r, echo = F, eval = F}
library(ggplot2)
library(ggstamp)

ggbarlabs() +
  stamp_polygon_inverse(radius_outer = Inf) +
  stamp_polygon(color = "darkred", 
                fill = "lightgoldenrod1",
                alpha = 0,
                size = 3) + 
  # stamp_arrow(x = -.75, xend = .75,
  #             y = 0, yend = 0,
  #             size = 4, 
  #             headlength = .2, 
  #             angle = 20,
  #             color = "darkseagreen", 
  #             type = "closed"
  #             ) + 
  stamp_text(#y = .35, x = -.25, 
    x = -.3, y = -.34,
             label = "ggbarlabs", 
             size = 12, 
             color = "dodgerblue4",
             vjust = 0) +
  theme_void()
```

# ggbarlabs

<!-- badges: start -->
<!-- badges: end -->

# Problem: 

## bar charts are ubiquitous and can quickly communicate information...

```{r}
library(ggplot2)
theme_set(theme_gray(18))
ggplot(mtcars) + 
  aes(x = am) + 
  geom_bar() 

p <- last_plot()

```


## ... and bar plots can benefit from specificity of labeling ...

Labeled bar chart is all the fast communication of traditional data vizualization with all the specificity of a data table.

```{r}



```


## ... but its a pain 

### either precalc and use geom_col + geom_text

🤔 🚧 I'm too lazy to even provide an example.

```{r}


```

###  or use verbose after_stat...

#### first inspecting bar layer (stat_count)

```{r}
layer_data(last_plot(), 1)
```

#### then plot

using our knowledge of what data frame results when using StatCount, refer to the computed var, count

```{r}
# count column can be used via after_stat
p +
  geom_text(stat = StatCount, 
            aes(label = after_stat(count)), 
            vjust = -.7)

p + 
  geom_text(stat = StatCount, 
            aes(label = after_stat(
              paste0(round(100*count/sum(count), 1) ,"%")
              )), 
            vjust = -.7)

p + 
  geom_text(stat = StatCount, 
            aes(label = after_stat(
              paste0(count,"\n(",round(100*count/sum(count), 1) ,"%)")
              )), 
            vjust = -.5, lineheight = .8)

layer_data(last_plot(), 2)
```



# What if...`ggbarlabs::geom_barlab_count()`! 

## Proposed User interface


```{r, eval = F}
ggplot(mtcars) + 
  aes(x = am) + 
  geom_bar() + 
  geom_barlab_count()

ggplot(mtcars) + 
  aes(x = am) + 
  geom_bar() + 
  geom_barlab_count_percent()
```


## Composing functions to this end

### `geom_barlab_count()`

🤔 🚧 likely rewrite, creating new ggproto stat, maybe using StatCount$compute as start point.  This might resolve y label issue which currently quotes 'after_stat()'.  See test below.  

June Choe, authored the first round ggdirect::geom_text_count and ggdirect::geom_text_count_percent, which proved super useful.  

 🚧 Main change below is to use vjust for y adjustment rather than nudge_y strategy... Any reason to go back? 'you can use numbers outside the range (0, 1), but it's not recommended.'
 
 

```{r geom_barlab_count}
#' geom_text_count
#' @description Add label which is the count.  Acts like geom_bar() but text label at the position of the top of the bar.
#'
#' @param vjust vertical justification, either a string (“top”, “middle”, “bottom”, “left”, “center”, “right”) or a number between 0 and 1; you can use numbers outside the range (0, 1), but it’s not recommended.
#' @param position Position adjustment, either as a string, or the result of a call to a position adjustment function. Cannot be jointly specified with nudge_x or nudge_y
#' @param ... Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.
#'
#' @return
#' @export
#'
#' @examples
geom_barlab_count <- function(vjust = -0.15, position =
                              ggplot2::position_dodge2(width = .9,
                                                       preserve = "single"), ...){

  ggplot2::stat_count(geom = "text",
                      ggplot2::aes(label = ggplot2::after_stat(count)),
                      vjust = vjust,
                      position = position,
                      ...
  )

}
```


### Test it out

🤔 🚧 Think about a new example, numeric as categories feels awkward


```{r}
library(ggplot2)
ggplot(mtcars) +
   aes(x = factor(cyl)) +
   geom_bar(position = "dodge") +
   geom_barlab_count()

last_plot() + 
  aes(fill = factor(am))
```


### `geom_barlab_count_percent`

🤔 🚧 likely rewrite creating new ggproto stat object.  Hopefully this would allow greater customizability in terms of defining denominator

```{r geom_barlab_count_percent}
#' geom_barlab_count_percent
#' @description Add label which is the count as well as percentage.  Acts like geom_bar() but text label at the position of the top of the bar.  Percentage is calculated within facet panels.
#'
#' @param vjust vertical justification, either a string (“top”, “middle”, “bottom”, “left”, “center”, “right”) or a number between 0 and 1; you can use numbers outside the range (0, 1), but it’s not recommended.
#' @param lineheight single to double spacing is the idea here
#' @param position Position adjustment, either as a string, or the result of a call to a position adjustment function. Cannot be jointly specified with nudge_x or nudge_y
#' @param ... Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.
#'
#' @return
#' @export
#'
#' @examples
geom_barlab_count_percent <- function(vjust = -0.1,
                                    lineheight = .85,
                                    position = ggplot2::position_dodge2(width = .9,
                                                               preserve = "single"), ...){

  ggplot2::stat_count(geom = "text",
             ggplot2::aes(label = paste0(ggplot2::after_stat(count), "\n(",

                                round(
                                  100*(ggplot2::after_stat(count))/
                                    tapply(ggplot2::after_stat(count),
                                           ggplot2::after_stat(PANEL),
                                           sum)[ggplot2::after_stat(PANEL)],
                                  1), "%)" )),
             vjust = vjust,
             lineheight = lineheight,
             position = position,
             ...
             )
}
```


### Try it out

```{r}
library(ggplot2)
ggplot(mtcars) +
    aes(x = factor(cyl)) +
    geom_bar(position = "dodge") +
    geom_barlab_count_percent()

last_plot() +
    aes(fill = factor(am))
```


# `ggbarlabs()` instead of `ggplot()` 

What if we start with a different set of thematic and scale defaults. And/or use `+ defaults_ggbarlabs()` to respecify defaults.

🤔 🚧 Consult with some people that think more about these choices and also who program more with ggplot2::theme()


```{r}
ggplot(mtcars) +
  aes(x = factor(cyl)) +
  geom_bar(position = "dodge") +
  geom_barlab_count(nudge_y = .2) +
  theme_classic() +
  theme(axis.line.y = element_blank(),
        axis.text.y.right = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_line(color = alpha("gray35", .1)),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.ticks = element_blank(),
        axis.line.x = element_line(colour = "gray35"),
        legend.position = "top",
        legend.justification = 0) +
  scale_y_continuous(expand = expansion(mult = c(0, .1)))
```

## Build `defaults_ggbarlabs` and `ggbarlabs()`

🤔 🚧 Is `defaults_ggbarlabs` a good name?   is providing a different start point, like `ggbarlabs()`, a good idea? Are there things that need to be changed about implementation?  While we are here, should we think about changing default color pallets?  



```{r defaults_ggbarlabs}
defaults_ggbarlabs <- function(){
  
  list(
  theme_classic(base_size = 15) ,
  theme(axis.line.y = element_blank(),
        axis.text.y.right = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_line(color = alpha("gray35", .1)),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.ticks = element_blank(),
        axis.line.x = element_line(colour = "gray35"),
        legend.position = "top",
        legend.justification = 0) ,
  scale_y_continuous(expand = expansion(mult = c(0, .15))))
}


ggbarlabs <- function(data = NULL, ...){
  ggplot(data= data , ... ) +
  defaults_ggbarlabs()
}
```

## try it out

```{r}
ggplot(mtcars) + 
  aes(x = factor(am)) + 
  geom_bar(fill = alpha("navy", .9)) + 
  geom_barlab_count_percent() + 
  defaults_ggbarlabs()

# or
ggbarlabs(mtcars) + 
  aes(x = factor(am), fill = factor(cyl)) + 
  geom_bar(position = "dodge") + 
  geom_barlab_count_percent()
```




# Issues/features lacking

- percents is calculated within panel.  We might want to specify the 'whole' from which percentage is calculated.
- Horizontal bars
- stacked barchart support (seems trickier, esp when bars are short)
- labels within bars... (trickier - when bars are short)

# Packaging and documentation

- `devtools::create("./ggbarlabs")`


## how does DESCRIPTION file look?  Have you worked on it? 

🚧 No! 


## Send functions composed in this readme to the package R folder w/ chunk names

```{r}
knitr::knit_code$get() |> names()
```

```{r}
library(readme2pkg)
chunk_to_r("geom_barlab_count")
chunk_to_r("geom_barlab_count_percent")
```

## have you added roxygen skeleton for auto documentation?

Yes!

## have you put examples in roxygen skeleton?

🚧 No.😬🤭

## have you written any formal tests?

🚧 No.😬🤭

## If yes to above, send tests in this readme to package via readme2pkg

That would look like this...

```
chunk_to_tests_testthat("test_geom_barlab_count")

```

## have you created a package website?

🚧 No.🤭😬


## Run check and capture errors, warnings, notes

🚧 🚧 🚧 🚧 🚧 🚧 🚧  Clearly lots to do.🤭🤭🤭😬

```{r, eval = F}
usethis::use_package("ggplot2")
usethis::use_mit_license()
```

```{r, error = T}
rm(list = c("geom_barlab_count", "geom_barlab_count_percent"))
devtools::check(pkg = ".")
```


